import { __decorate } from "tslib";
import { WebSocketConnection } from '@d-fischer/connection';
import { delay, Enumerable, fibWithLimit } from '@d-fischer/shared-utils';
import { HellFreezesOverError } from '@twurple/api';
import { InvalidTokenTypeError } from '@twurple/auth';
import { rtfm } from '@twurple/common';
import { EventSubBase } from '@twurple/eventsub-base';
/**
 * A WebSocket listener for the Twitch EventSub event distribution mechanism.
 *
 * @beta
 * @hideProtected
 * @inheritDoc
 *
 * @meta category main
 */
let EventSubWsListener = class EventSubWsListener extends EventSubBase {
    /**
     * Creates a new EventSub HTTP listener.
     *
     * @param config
     *
     * @expandParams
     */
    constructor(config) {
        var _a;
        if (config.apiClient._authProvider.tokenType !== 'user') {
            throw new InvalidTokenTypeError('EventSub over WebSockets requires user access tokens to work.');
        }
        super(config);
        this._initialUrl = (_a = config.url) !== null && _a !== void 0 ? _a : 'wss://eventsub-beta.wss.twitch.tv/ws';
        this._connecting = false;
        this._reconnectInProgress = false;
        this._keepaliveTimeout = null;
        this._keepaliveTimer = null;
    }
    /**
     * Starts the WebSocket listener.
     */
    async start() {
        const welcomePromise = new Promise(resolve => (this._welcomeCallback = resolve));
        await this._connect();
        await welcomePromise;
    }
    /**
     * Stops the WebSocket listener.
     */
    async stop() {
        if (this._connection) {
            await Promise.all([...this._subscriptions.values()].map(async (sub) => await sub.suspend()));
            await this._disconnect();
        }
    }
    /** @private */
    async _getCliTestCommandForSubscription() {
        throw new Error("Testing WebSocket subscriptions currently isn't supported by the CLI");
    }
    /** @private */
    async _getTransportOptionsForSubscription() {
        if (!this._sessionId) {
            throw new HellFreezesOverError('Listener is not connected or does not have a session ID yet');
        }
        return {
            method: 'websocket',
            // eslint-disable-next-line @typescript-eslint/naming-convention
            session_id: this._sessionId
        };
    }
    _findTwitchSubscriptionToContinue() {
        return undefined;
    }
    async _connect() {
        await this._connectTo(this._initialUrl);
    }
    async _connectTo(url) {
        if (this._connection) {
            this._welcomeCallback = undefined;
            throw new Error('Trying to connect while already connected');
        }
        this._connecting = true;
        const retryTimerGenerator = fibWithLimit(120);
        while (true) {
            const newConnection = (this._connection = new WebSocketConnection({ url }, { logger: this._logger }));
            newConnection.onDisconnect(async (manually, reason) => {
                this._readyToSubscribe = false;
                this._clearKeepaliveTimer();
                this._keepaliveTimeout = null;
                if (manually) {
                    if (this._reconnectInProgress) {
                        this._logger.debug('Reconnect: old connection cleaned up');
                    }
                    else {
                        this._logger.info('Disconnected');
                    }
                    void newConnection.disconnect();
                    if (this._connection === newConnection) {
                        this._connection = undefined;
                    }
                }
                else {
                    if (reason) {
                        this._logger.warn(`Disconnected unexpectedly: ${reason.message}; trying to reconnect`);
                    }
                    else {
                        this._logger.warn('Disconnected unexpectedly; trying to reconnect');
                    }
                    if (!this._connecting) {
                        void this._reconnect();
                    }
                }
            });
            this._connection.onReceive(async (data) => {
                var _a;
                this._logger.debug(`Received data: ${data.trim()}`);
                const { metadata, payload } = JSON.parse(data);
                switch (metadata.message_type) {
                    case 'session_welcome': {
                        this._logger.info(this._reconnectInProgress
                            ? 'Reconnect: new connection established'
                            : 'Connection established');
                        this._sessionId = payload.session.id;
                        this._readyToSubscribe = true;
                        const welcomeCallbackPromise = (_a = this._welcomeCallback) === null || _a === void 0 ? void 0 : _a.call(this);
                        this._welcomeCallback = undefined;
                        await welcomeCallbackPromise;
                        if (!this._reconnectInProgress) {
                            await Promise.all([...this._subscriptions.values()].map(async (sub) => await sub.start()));
                        }
                        this._initializeKeepaliveTimeout(payload.session.keepalive_timeout_seconds);
                        this._reconnectInProgress = false;
                        break;
                    }
                    case 'session_keepalive': {
                        this._restartKeepaliveTimer();
                        break;
                    }
                    case 'session_reconnect': {
                        this._logger.info('Reconnect message received; initiating new connection');
                        this._reconnectInProgress = true;
                        const oldConnection = this._connection;
                        this._connection = undefined;
                        this._welcomeCallback = async () => await oldConnection.disconnect();
                        await this._connectTo(payload.session.reconnect_url);
                        break;
                    }
                    case 'notification': {
                        this._restartKeepaliveTimer();
                        const id = payload.subscription.id;
                        const subscription = this._getCorrectSubscriptionByTwitchId(id);
                        if (!subscription) {
                            this._logger.error(`Notification from unknown event received: ${id}`);
                            break;
                        }
                        subscription._handleData(payload.event);
                        break;
                    }
                    case 'revocation': {
                        const id = payload.subscription.id;
                        const subscription = this._getCorrectSubscriptionByTwitchId(id);
                        if (!subscription) {
                            this._logger.error(`Revocation from unknown event received: ${id}`);
                            break;
                        }
                        this._dropSubscription(subscription.id);
                        this._dropTwitchSubscription(subscription.id);
                        this.emit(this.onRevoke, subscription);
                        this._logger.debug(`Subscription revoked by Twitch for event: ${id}`);
                        break;
                    }
                    default: {
                        this._logger.warn(`Unknown message type encountered: ${metadata.message_type}`);
                    }
                }
            });
            try {
                await this._connection.connect();
                this._connecting = false;
                return;
            }
            catch (e) {
                if (!this._connecting) {
                    return;
                }
                this._logger.debug(`Connection error caught: ${e.message}`);
                const secs = retryTimerGenerator.next().value;
                if (secs !== 0) {
                    this._logger.info(`Retrying in ${secs} seconds`);
                }
                await delay(secs * 1000);
                this._logger.info('Trying to reconnect');
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                if (!this._connecting) {
                    return;
                }
            }
        }
    }
    async _disconnect() {
        this._connecting = false;
        if (this._connection) {
            const lastConnection = this._connection;
            this._connection = undefined;
            await lastConnection.disconnect();
        }
    }
    async _reconnect() {
        void this._disconnect().catch((e) => this._logger.error(`Error while disconnecting for the reconnect: ${e.message}`));
        await this._connect();
    }
    _initializeKeepaliveTimeout(timeoutInSeconds) {
        this._keepaliveTimeout = timeoutInSeconds;
        this._restartKeepaliveTimer();
    }
    _clearKeepaliveTimer() {
        if (this._keepaliveTimer) {
            clearTimeout(this._keepaliveTimer);
            this._keepaliveTimer = null;
        }
    }
    _restartKeepaliveTimer() {
        this._clearKeepaliveTimer();
        if (this._keepaliveTimeout) {
            // 1200 instead of 1000 to allow for a little more leeway than Twitch wants to give us
            this._keepaliveTimer = setTimeout(() => this._handleKeepaliveTimeout(), this._keepaliveTimeout * 1200);
        }
    }
    _handleKeepaliveTimeout() {
        var _a;
        this._keepaliveTimer = null;
        (_a = this._connection) === null || _a === void 0 ? void 0 : _a.assumeExternalDisconnect();
    }
};
__decorate([
    Enumerable(false)
], EventSubWsListener.prototype, "_connection", void 0);
__decorate([
    Enumerable(false)
], EventSubWsListener.prototype, "_sessionId", void 0);
__decorate([
    Enumerable(false)
], EventSubWsListener.prototype, "_welcomeCallback", void 0);
EventSubWsListener = __decorate([
    rtfm('eventsub-ws', 'EventSubWsListener')
], EventSubWsListener);
export { EventSubWsListener };
